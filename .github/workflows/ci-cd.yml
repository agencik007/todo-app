name: CI/CD Pipeline

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main, develop ]
  workflow_dispatch:

permissions:
  contents: read
  packages: write
  security-events: write

env:
  REGISTRY: ghcr.io
  BACKEND_IMAGE: ghcr.io/${{ github.repository }}/backend
  FRONTEND_IMAGE: ghcr.io/${{ github.repository }}/frontend

jobs:
  # Test backend
  test-backend:
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: backend

    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_USER: test_user
          POSTGRES_PASSWORD: test_password
          POSTGRES_DB: test_db
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.12'

    - name: Cache pip dependencies
      uses: actions/cache@v3
      with:
        path: ~/.cache/pip
        key: ${{ runner.os }}-pip-${{ hashFiles('backend/requirements.txt') }}
        restore-keys: |
          ${{ runner.os }}-pip-

    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt

    - name: Run tests with coverage
      run: python -m pytest tests/ -v --cov=. --cov-report=xml

    - name: Upload coverage to Codecov
      uses: codecov/codecov-action@v3
      with:
        file: backend/coverage.xml
        flags: backend
        name: backend-coverage

  # Build and test frontend
  test-frontend:
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: frontend

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '22'
        cache: 'npm'
        cache-dependency-path: frontend/package-lock.json

    - name: Install dependencies
      run: npm ci

    - name: Check TypeScript compilation
      run: npx tsc --noEmit

    - name: Build for production
      run: npm run build --configuration=production

    - name: Upload build artifacts
      uses: actions/upload-artifact@v4
      with:
        name: frontend-build
        path: frontend/dist/

  # Security checks
  security-check:
    runs-on: ubuntu-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Run Trivy vulnerability scanner
      uses: aquasecurity/trivy-action@0.28.0
      with:
        scan-type: 'fs'
        scan-ref: '.'
        format: 'sarif'
        output: 'trivy-results.sarif'

    - name: Upload Trivy scan results
      uses: github/codeql-action/upload-sarif@v3
      if: always()
      with:
        sarif_file: 'trivy-results.sarif'

  # Build and push Docker images
  build-and-push:
    needs: [test-backend, test-frontend, security-check]
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Log in to Container Registry
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}

    - name: Extract metadata for backend
      id: meta-backend
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.BACKEND_IMAGE }}
        tags: |
          type=ref,event=branch
          type=ref,event=pr
          type=sha,prefix={{branch}}-
          type=raw,value=latest,enable={{is_default_branch}}

    - name: Build and push backend image
      uses: docker/build-push-action@v5
      with:
        context: .
        file: ./docker/Dockerfile.backend
        push: true
        tags: ${{ steps.meta-backend.outputs.tags }}
        labels: ${{ steps.meta-backend.outputs.labels }}

    - name: Extract metadata for frontend
      id: meta-frontend
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.FRONTEND_IMAGE }}
        tags: |
          type=ref,event=branch
          type=ref,event=pr
          type=sha,prefix={{branch}}-
          type=raw,value=latest,enable={{is_default_branch}}

    - name: Build and push frontend image
      uses: docker/build-push-action@v5
      with:
        context: .
        file: ./docker/Dockerfile.frontend
        push: true
        tags: ${{ steps.meta-frontend.outputs.tags }}
        labels: ${{ steps.meta-frontend.outputs.labels }}

  # Deploy to staging (optional)
  deploy-staging:
    needs: [build-and-push]
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/develop' && github.event_name == 'push'
    environment: staging

    steps:
    - name: Deploy to staging
      run: |
        echo "Deploying to staging environment..."
        # Add your deployment commands here
        # Example: kubectl apply, docker-compose up, etc.

  # Deploy to production
  deploy-production:
    needs: [build-and-push]
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    environment: production

    steps:
    - name: Check deployment secrets
      run: |
        if [ -z "$SERVER_HOST" ]; then echo "SERVER_HOST is not set"; exit 1; fi
        if [ -z "$SERVER_USER" ]; then echo "SERVER_USER is not set"; exit 1; fi
        if [ -z "$SSH_PRIVATE_KEY" ]; then echo "SSH_PRIVATE_KEY is not set"; exit 1; fi
        echo "All deployment secrets are configured"
      env:
        SERVER_HOST: ${{ secrets.SERVER_HOST }}
        SERVER_USER: ${{ secrets.SERVER_USER }}
        SSH_PRIVATE_KEY: ${{ secrets.SSH_PRIVATE_KEY }}

    - name: Check server connectivity
      run: |
        echo "üîç Checking server connectivity..."
        echo "Server IP: ${{ secrets.SERVER_HOST }}"

        # Test basic connectivity
        ping -c 3 ${{ secrets.SERVER_HOST }} || echo "‚ùå Ping failed (may be blocked by firewall)"

        # Test SSH port
        timeout 10 nc -zv ${{ secrets.SERVER_HOST }} 22 || echo "‚ùå Cannot reach SSH port 22"

        # Test HTTP port (if available)
        timeout 5 nc -zv ${{ secrets.SERVER_HOST }} 80 || echo "‚ùå Cannot reach HTTP port 80"

        echo "‚úÖ Connectivity check completed"

        # If SSH fails, provide troubleshooting info
        if ! timeout 5 nc -zv ${{ secrets.SERVER_HOST }} 22 2>/dev/null; then
          echo "üîß TROUBLESHOOTING:"
          echo "1. Check if instance has Public IP"
          echo "2. Verify Security Lists allow port 22"
          echo "3. Check Network Security Groups (NSG)"
          echo "4. Ensure instance is in Public Subnet"
          echo "5. Check if firewall on instance blocks SSH"
        fi

    - name: Debug SSH
      run: |
        echo "üîß Testing SSH manually..."
        
        # Create .ssh directory and known_hosts if not exists
        mkdir -p ~/.ssh
        chmod 700 ~/.ssh
        touch ~/.ssh/known_hosts
        chmod 644 ~/.ssh/known_hosts
        
        # Add server to known_hosts
        ssh-keyscan -H ${{ secrets.SERVER_HOST }} >> ~/.ssh/known_hosts 2>/dev/null || echo "keyscan failed"
        
        # Create temporary key file
        echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/temp_key
        chmod 600 ~/.ssh/temp_key
        
        # Test SSH connection
        echo "üîë Testing SSH connection..."
        ssh -o ConnectTimeout=10 -o StrictHostKeyChecking=no -i ~/.ssh/temp_key ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} "echo 'SSH connection successful!'; whoami; pwd" || echo "‚ùå SSH failed"
        
        # Cleanup
        rm -f ~/.ssh/temp_key    

    - name: Deploy to Oracle Cloud
      uses: appleboy/ssh-action@v1.0.3
      with:
        host: ${{ secrets.SERVER_HOST }}
        username: ${{ secrets.SERVER_USER }}
        key: ${{ secrets.SSH_PRIVATE_KEY }}
        port: 22
        timeout: 60s
        debug: true
        script_stop: true
        script: |
          # Disable exit on error temporarily for debugging
          set +e

          # Debug: Show current user and directory
          echo "üîç Current user: $(whoami)"
          echo "üîç Current directory: $(pwd)"
          echo "üîç Home directory: $HOME"

          # Cleanup: Stop any existing containers first
          echo "üßπ Cleaning up existing containers..."

          # Test Docker access first
          echo "üîç Testing Docker access..."
          if docker ps >/dev/null 2>&1; then
            echo "‚úÖ Docker accessible without sudo"
            DOCKER_CMD="docker"
          else
            echo "üîÑ Testing Docker access with sudo..."
            if sudo docker ps >/dev/null 2>&1; then
              echo "‚úÖ Docker accessible with sudo"
              DOCKER_CMD="sudo docker"
            else
              echo "‚ùå Docker not accessible"
              exit 1
            fi
          fi

          # Stop running containers
          if $DOCKER_CMD ps -q | grep -q .; then
            echo "üìã Found running containers, stopping them..."
            $DOCKER_CMD stop $($DOCKER_CMD ps -q) 2>/dev/null || echo "‚ö†Ô∏è Could not stop some containers"
          fi

          # Remove stopped containers
          if $DOCKER_CMD ps -a -q | grep -q .; then
            echo "üìã Found stopped containers, removing them..."
            $DOCKER_CMD rm $($DOCKER_CMD ps -a -q) 2>/dev/null || echo "‚ö†Ô∏è Could not remove some containers"
          fi

          # Clean up unused images and volumes
          $DOCKER_CMD system prune -f 2>/dev/null || echo "‚ö†Ô∏è Could not prune system"
          echo "‚úÖ Cleanup completed"
          
          # Show disk space and permissions
          echo "üîç Disk space:"
          df -h $HOME
          echo "üîç Home directory permissions:"
          ls -la $HOME
          
          # Check if project directory exists
          PROJECT_DIR="$HOME/todo-app"
          echo "üîç Checking if project directory exists: $PROJECT_DIR"

          # Try ls command and capture result
          echo "üîç Listing home directory contents..."
          HOME_LISTING=$(ls -la "$HOME/")
          LS_RESULT=$?
          echo "üîç LS result: $LS_RESULT"
          echo "$HOME_LISTING"

          echo "üîç Checking for todo-app in listing..."
          echo "$HOME_LISTING" | grep -i todo-app || echo "üìÅ todo-app directory not visible in listing"
          
          # Check if directory exists and is accessible
          echo "üîç Testing directory accessibility..."
          echo "üîç PROJECT_DIR variable: '$PROJECT_DIR'"

          if [ -d "$PROJECT_DIR" ]; then
            echo "üìÅ Project directory found, updating..."
            cd "$PROJECT_DIR" || {
              echo "‚ùå Cannot access project directory"
              exit 1
            }
            echo "‚úÖ Successfully entered project directory"

            # Pull latest changes
            git pull origin main || echo "‚ö†Ô∏è Git pull failed"
          else
            echo "üìÅ Project directory not found, cloning..."
            cd "$HOME" || {
              echo "‚ùå Cannot access home directory"
              exit 1
            }
            git clone https://github.com/${{ github.repository }}.git todo-app || {
              echo "‚ùå Git clone failed"
              exit 1
            }
            cd todo-app || {
              echo "‚ùå Cannot access cloned directory"
              exit 1
            }
          fi
          
          echo "üìÇ Current directory after setup: $(pwd)"
          echo "üìã Directory contents:"
          ls -la

          # Check if docker directory exists
          echo "üîç Looking for docker directory..."
          ls -la | grep docker || echo "üìÅ Docker directory not visible in listing"
          
          if [ ! -d "docker" ]; then
            echo "‚ùå Docker directory not found!"
            echo "üìã Available directories:"
            ls -la
            exit 1
          fi

          # Navigate to docker directory
          echo "üîÑ Attempting to enter docker directory..."
          cd docker
          DOCKER_CD_RESULT=$?
          echo "üîç Docker CD result: $DOCKER_CD_RESULT"
          
          if [ $DOCKER_CD_RESULT -ne 0 ]; then
            echo "‚ùå Cannot enter docker directory"
            exit 1
          fi
          
          echo "üìÇ Successfully in docker directory: $(pwd)"
          echo "üìã Docker directory contents:"
          ls -la

          # Check if user can run docker
          echo "üê≥ Checking Docker access..."
          if ! docker ps > /dev/null 2>&1; then
            echo "‚ùå Docker access failed, trying with sudo..."
            if ! sudo docker ps > /dev/null 2>&1; then
              echo "‚ùå Docker not accessible even with sudo"
              exit 1
            fi
            echo "‚úÖ Docker accessible with sudo"
            
            # Use sudo for docker commands
            echo "üîΩ Stopping existing containers (sudo)..."
            sudo docker-compose down 2>&1 || echo "‚ö†Ô∏è Docker compose down failed"
            
            echo "üöÄ Starting containers (sudo)..."
            sudo docker-compose up -d --build 2>&1 || {
              echo "‚ùå Docker compose up failed"
              echo "üìã Checking logs..."
              sudo docker-compose logs --tail=20
              exit 1
            }
            
            echo "üßπ Cleaning up old images (sudo)..."
            sudo docker image prune -f 2>&1 || echo "‚ö†Ô∏è Image prune failed"
            
            echo "üìä Final container status:"
            sudo docker-compose ps
            echo "‚úÖ Deployment completed successfully!"
            exit 0
          fi

          # Regular docker commands (without sudo)
          echo "‚úÖ Docker accessible without sudo"
          
          echo "üîΩ Stopping existing containers..."
          docker-compose down 2>&1 || echo "‚ö†Ô∏è Docker compose down failed"

          echo "üöÄ Starting containers..."
          docker-compose up -d --build 2>&1 || {
            echo "‚ùå Docker compose up failed"
            echo "üìã Checking logs..."
            docker-compose logs --tail=20
            exit 1
          }

          echo "üßπ Cleaning up old images..."
          docker image prune -f 2>&1 || echo "‚ö†Ô∏è Image prune failed"

          echo "üìä Final container status:"
          docker-compose ps
          echo "‚úÖ Deployment completed successfully!"
