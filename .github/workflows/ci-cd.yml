name: CI/CD Pipeline

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main, develop ]
  workflow_dispatch:

permissions:
  contents: read
  packages: write
  security-events: write

env:
  REGISTRY: ghcr.io
  BACKEND_IMAGE: ghcr.io/${{ github.repository }}/backend
  FRONTEND_IMAGE: ghcr.io/${{ github.repository }}/frontend

jobs:
  # Test backend
  test-backend:
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: backend

    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_USER: test_user
          POSTGRES_PASSWORD: test_password
          POSTGRES_DB: test_db
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.12'

    - name: Cache pip dependencies
      uses: actions/cache@v3
      with:
        path: ~/.cache/pip
        key: ${{ runner.os }}-pip-${{ hashFiles('backend/requirements.txt') }}
        restore-keys: |
          ${{ runner.os }}-pip-

    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt

    - name: Run tests with coverage
      run: python -m pytest tests/ -v --cov=. --cov-report=xml

    - name: Upload coverage to Codecov
      uses: codecov/codecov-action@v3
      with:
        file: backend/coverage.xml
        flags: backend
        name: backend-coverage

  # Build and test frontend
  test-frontend:
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: frontend

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '22'
        cache: 'npm'
        cache-dependency-path: frontend/package-lock.json

    - name: Install dependencies
      run: npm ci

    - name: Check TypeScript compilation
      run: npx tsc --noEmit

    - name: Build for production
      run: npm run build --configuration=production

    - name: Upload build artifacts
      uses: actions/upload-artifact@v4
      with:
        name: frontend-build
        path: frontend/dist/

  # Security checks
  security-check:
    runs-on: ubuntu-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Run Trivy vulnerability scanner
      uses: aquasecurity/trivy-action@0.28.0
      with:
        scan-type: 'fs'
        scan-ref: '.'
        format: 'sarif'
        output: 'trivy-results.sarif'

    - name: Upload Trivy scan results
      uses: github/codeql-action/upload-sarif@v3
      if: always()
      with:
        sarif_file: 'trivy-results.sarif'

  # Build and push Docker images
  build-and-push:
    needs: [test-backend, test-frontend, security-check]
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Log in to Container Registry
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}

    - name: Extract metadata for backend
      id: meta-backend
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.BACKEND_IMAGE }}
        tags: |
          type=ref,event=branch
          type=ref,event=pr
          type=sha,prefix={{branch}}-
          type=raw,value=latest,enable={{is_default_branch}}

    - name: Build and push backend image
      uses: docker/build-push-action@v5
      with:
        context: .
        file: ./docker/Dockerfile.backend
        push: true
        tags: ${{ steps.meta-backend.outputs.tags }}
        labels: ${{ steps.meta-backend.outputs.labels }}

    - name: Extract metadata for frontend
      id: meta-frontend
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.FRONTEND_IMAGE }}
        tags: |
          type=ref,event=branch
          type=ref,event=pr
          type=sha,prefix={{branch}}-
          type=raw,value=latest,enable={{is_default_branch}}

    - name: Build and push frontend image
      uses: docker/build-push-action@v5
      with:
        context: .
        file: ./docker/Dockerfile.frontend
        push: true
        tags: ${{ steps.meta-frontend.outputs.tags }}
        labels: ${{ steps.meta-frontend.outputs.labels }}

  # Deploy to staging (optional)
  deploy-staging:
    needs: [build-and-push]
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/develop' && github.event_name == 'push'
    environment: staging

    steps:
    - name: Deploy to staging
      run: |
        echo "Deploying to staging environment..."
        # Add your deployment commands here
        # Example: kubectl apply, docker-compose up, etc.

  # Deploy to production
  deploy-production:
    needs: [build-and-push]
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    environment: production

    steps:
    - name: Check deployment secrets
      run: |
        if [ -z "$SERVER_HOST" ]; then echo "SERVER_HOST is not set"; exit 1; fi
        if [ -z "$SERVER_USER" ]; then echo "SERVER_USER is not set"; exit 1; fi
        if [ -z "$SSH_PRIVATE_KEY" ]; then echo "SSH_PRIVATE_KEY is not set"; exit 1; fi
        echo "All deployment secrets are configured"
      env:
        SERVER_HOST: ${{ secrets.SERVER_HOST }}
        SERVER_USER: ${{ secrets.SERVER_USER }}
        SSH_PRIVATE_KEY: ${{ secrets.SSH_PRIVATE_KEY }}

    - name: Check server connectivity
      run: |
        echo "ğŸ” Checking server connectivity..."
        echo "Server IP: ${{ secrets.SERVER_HOST }}"

        # Test basic connectivity
        ping -c 3 ${{ secrets.SERVER_HOST }} || echo "âŒ Ping failed (may be blocked by firewall)"

        # Test SSH port
        timeout 10 nc -zv ${{ secrets.SERVER_HOST }} 22 || echo "âŒ Cannot reach SSH port 22"

        # Test HTTP port (if available)
        timeout 5 nc -zv ${{ secrets.SERVER_HOST }} 80 || echo "âŒ Cannot reach HTTP port 80"

        echo "âœ… Connectivity check completed"

        # If SSH fails, provide troubleshooting info
        if ! timeout 5 nc -zv ${{ secrets.SERVER_HOST }} 22 2>/dev/null; then
          echo "ğŸ”§ TROUBLESHOOTING:"
          echo "1. Check if instance has Public IP"
          echo "2. Verify Security Lists allow port 22"
          echo "3. Check Network Security Groups (NSG)"
          echo "4. Ensure instance is in Public Subnet"
          echo "5. Check if firewall on instance blocks SSH"
        fi

    - name: Debug SSH
      run: |
        echo "ğŸ”§ Testing SSH manually..."
        
        # Create .ssh directory and known_hosts if not exists
        mkdir -p ~/.ssh
        chmod 700 ~/.ssh
        touch ~/.ssh/known_hosts
        chmod 644 ~/.ssh/known_hosts
        
        # Add server to known_hosts
        ssh-keyscan -H ${{ secrets.SERVER_HOST }} >> ~/.ssh/known_hosts 2>/dev/null || echo "keyscan failed"
        
        # Create temporary key file
        echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/temp_key
        chmod 600 ~/.ssh/temp_key
        
        # Test SSH connection
        echo "ğŸ”‘ Testing SSH connection..."
        ssh -o ConnectTimeout=10 -o StrictHostKeyChecking=no -i ~/.ssh/temp_key ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} "echo 'SSH connection successful!'; whoami; pwd" || echo "âŒ SSH failed"
        
        # Cleanup
        rm -f ~/.ssh/temp_key    

    - name: Deploy to Oracle Cloud
      uses: appleboy/ssh-action@v1.0.3
      with:
        host: ${{ secrets.SERVER_HOST }}
        username: ${{ secrets.SERVER_USER }}
        key: ${{ secrets.SSH_PRIVATE_KEY }}
        port: 22
        timeout: 60s
        debug: true
        script_stop: true
        script: |
          # Disable exit on error temporarily for debugging
          set +e

          # Debug: Show current user and directory
          echo "ğŸ” Current user: $(whoami)"
          echo "ğŸ” Current directory: $(pwd)"
          echo "ğŸ” Home directory: $HOME"

          # Cleanup: Stop any existing containers first
          echo "ğŸ§¹ Cleaning up existing containers..."

          # Test Docker access first
          echo "ğŸ” Testing Docker access..."
          if docker ps >/dev/null 2>&1; then
            echo "âœ… Docker accessible without sudo"
            DOCKER_CMD="docker"
          else
            echo "ğŸ”„ Testing Docker access with sudo..."
            if sudo docker ps >/dev/null 2>&1; then
              echo "âœ… Docker accessible with sudo"
              DOCKER_CMD="sudo docker"
            else
              echo "âŒ Docker not accessible"
              exit 1
            fi
          fi

          # Stop running containers
          if $DOCKER_CMD ps -q | grep -q .; then
            echo "ğŸ“‹ Found running containers, stopping them..."
            $DOCKER_CMD stop $($DOCKER_CMD ps -q) 2>/dev/null || echo "âš ï¸ Could not stop some containers"
          fi

          # Remove stopped containers
          if $DOCKER_CMD ps -a -q | grep -q .; then
            echo "ğŸ“‹ Found stopped containers, removing them..."
            $DOCKER_CMD rm $($DOCKER_CMD ps -a -q) 2>/dev/null || echo "âš ï¸ Could not remove some containers"
          fi

          # Clean up unused images and volumes
          $DOCKER_CMD system prune -f 2>/dev/null || echo "âš ï¸ Could not prune system"
          echo "âœ… Cleanup completed"
          
          # Show disk space and permissions
          echo "ğŸ” Disk space:"
          df -h $HOME
          echo "ğŸ” Home directory permissions:"
          ls -la $HOME
          
          # Check if project directory exists
          PROJECT_DIR="$HOME/todo-app"
          echo "ğŸ” Checking if project directory exists: $PROJECT_DIR"

          # Try ls command and capture result
          echo "ğŸ” Listing home directory contents..."
          HOME_LISTING=$(ls -la "$HOME/")
          LS_RESULT=$?
          echo "ğŸ” LS result: $LS_RESULT"
          echo "$HOME_LISTING"

          echo "ğŸ” Checking for todo-app in listing..."
          echo "$HOME_LISTING" | grep -i todo-app || echo "ğŸ“ todo-app directory not visible in listing"
          
          # Check if directory exists and is accessible
          echo "ğŸ” Testing directory accessibility..."
          echo "ğŸ” PROJECT_DIR variable: '$PROJECT_DIR'"

          if [ -d "$PROJECT_DIR" ]; then
            echo "ğŸ“ Project directory found, updating..."
            cd "$PROJECT_DIR" || {
              echo "âŒ Cannot access project directory"
              exit 1
            }
            echo "âœ… Successfully entered project directory"

            # Pull latest changes
            git pull origin main || echo "âš ï¸ Git pull failed"
          else
            echo "ğŸ“ Project directory not found, cloning..."
            cd "$HOME" || {
              echo "âŒ Cannot access home directory"
              exit 1
            }
            git clone https://github.com/${{ github.repository }}.git todo-app || {
              echo "âŒ Git clone failed"
              exit 1
            }
            cd todo-app || {
              echo "âŒ Cannot access cloned directory"
              exit 1
            }
          fi
          
          echo "ğŸ“‚ Current directory after setup: $(pwd)"
          echo "ğŸ“‹ Directory contents:"
          ls -la

          # Check if docker directory exists
          echo "ğŸ” Looking for docker directory..."
          ls -la | grep docker || echo "ğŸ“ Docker directory not visible in listing"
          
          if [ ! -d "docker" ]; then
            echo "âŒ Docker directory not found!"
            echo "ğŸ“‹ Available directories:"
            ls -la
            exit 1
          fi

          # Navigate to docker directory
          echo "ğŸ”„ Attempting to enter docker directory..."
          cd docker
          DOCKER_CD_RESULT=$?
          echo "ğŸ” Docker CD result: $DOCKER_CD_RESULT"
          
          if [ $DOCKER_CD_RESULT -ne 0 ]; then
            echo "âŒ Cannot enter docker directory"
            exit 1
          fi
          
          echo "ğŸ“‚ Successfully in docker directory: $(pwd)"
          echo "ğŸ“‹ Docker directory contents:"
          ls -la

          # Check if user can run docker
          echo "ğŸ³ Checking Docker access..."
          if ! docker ps > /dev/null 2>&1; then
            echo "âŒ Docker access failed, trying with sudo..."
            if ! sudo docker ps > /dev/null 2>&1; then
              echo "âŒ Docker not accessible even with sudo"
              exit 1
            fi
            echo "âœ… Docker accessible with sudo"
            
            # Use sudo for docker commands
            echo "ğŸ”½ Stopping existing containers (sudo)..."
            sudo docker-compose down 2>&1 || echo "âš ï¸ Docker compose down failed"
            
            echo "ğŸš€ Starting containers (sudo)..."
            sudo docker-compose up -d --build 2>&1 || {
              echo "âŒ Docker compose up failed"
              echo "ğŸ“‹ Checking logs..."
              sudo docker-compose logs --tail=20
              exit 1
            }
            
            echo "ğŸ§¹ Cleaning up old images (sudo)..."
            sudo docker image prune -f 2>&1 || echo "âš ï¸ Image prune failed"
            
            echo "ğŸ“Š Final container status:"
            sudo docker-compose ps
            echo "âœ… Deployment completed successfully!"
            exit 0
          fi

          # Regular docker commands (without sudo)
          echo "âœ… Docker accessible without sudo"
          
          echo "ğŸ”½ Stopping existing containers..."
          docker-compose down 2>&1 || echo "âš ï¸ Docker compose down failed"

          echo "ğŸš€ Starting containers..."
          docker-compose up -d --build 2>&1 || {
            echo "âŒ Docker compose up failed"
            echo "ğŸ“‹ Checking logs..."
            docker-compose logs --tail=20
            exit 1
          }

          echo "ğŸ§¹ Cleaning up old images..."
          docker image prune -f 2>&1 || echo "âš ï¸ Image prune failed"

          echo "ğŸ“Š Final container status:"
          docker-compose ps
          echo "âœ… Deployment completed successfully!"
