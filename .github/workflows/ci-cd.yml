name: CI/CD Pipeline

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main, develop ]
  workflow_dispatch:

permissions:
  contents: read
  packages: write
  security-events: write

env:
  REGISTRY: ghcr.io
  BACKEND_IMAGE: ghcr.io/${{ github.repository }}/backend
  FRONTEND_IMAGE: ghcr.io/${{ github.repository }}/frontend

jobs:
  # Test backend
  test-backend:
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: backend

    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_USER: test_user
          POSTGRES_PASSWORD: test_password
          POSTGRES_DB: test_db
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.12'

    - name: Cache pip dependencies
      uses: actions/cache@v3
      with:
        path: ~/.cache/pip
        key: ${{ runner.os }}-pip-${{ hashFiles('backend/requirements.txt') }}
        restore-keys: |
          ${{ runner.os }}-pip-

    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt

    - name: Run tests with coverage
      run: python -m pytest tests/ -v --cov=. --cov-report=xml

    - name: Upload coverage to Codecov
      uses: codecov/codecov-action@v3
      with:
        file: backend/coverage.xml
        flags: backend
        name: backend-coverage

  # Build and test frontend
  test-frontend:
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: frontend

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '22'
        cache: 'npm'
        cache-dependency-path: frontend/package-lock.json

    - name: Install dependencies
      run: npm ci

    - name: Check TypeScript compilation
      run: npx tsc --noEmit

    - name: Build for production
      run: npm run build --configuration=production

    - name: Upload build artifacts
      uses: actions/upload-artifact@v4
      with:
        name: frontend-build
        path: frontend/dist/

  # Security checks
  security-check:
    runs-on: ubuntu-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Run Trivy vulnerability scanner
      uses: aquasecurity/trivy-action@0.28.0
      with:
        scan-type: 'fs'
        scan-ref: '.'
        format: 'sarif'
        output: 'trivy-results.sarif'

    - name: Upload Trivy scan results
      uses: github/codeql-action/upload-sarif@v3
      if: always()
      with:
        sarif_file: 'trivy-results.sarif'

  # Build and push Docker images
  build-and-push:
    needs: [test-backend, test-frontend, security-check]
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Log in to Container Registry
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}

    - name: Extract metadata for backend
      id: meta-backend
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.BACKEND_IMAGE }}
        tags: |
          type=ref,event=branch
          type=ref,event=pr
          type=sha,prefix={{branch}}-
          type=raw,value=latest,enable={{is_default_branch}}

    - name: Build and push backend image
      uses: docker/build-push-action@v5
      with:
        context: .
        file: ./docker/Dockerfile.backend
        push: true
        tags: ${{ steps.meta-backend.outputs.tags }}
        labels: ${{ steps.meta-backend.outputs.labels }}

    - name: Extract metadata for frontend
      id: meta-frontend
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.FRONTEND_IMAGE }}
        tags: |
          type=ref,event=branch
          type=ref,event=pr
          type=sha,prefix={{branch}}-
          type=raw,value=latest,enable={{is_default_branch}}

    - name: Build and push frontend image
      uses: docker/build-push-action@v5
      with:
        context: .
        file: ./docker/Dockerfile.frontend
        push: true
        tags: ${{ steps.meta-frontend.outputs.tags }}
        labels: ${{ steps.meta-frontend.outputs.labels }}

  # Deploy to staging (optional)
  deploy-staging:
    needs: [build-and-push]
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/develop' && github.event_name == 'push'
    environment: staging

    steps:
    - name: Deploy to staging
      run: |
        echo "Deploying to staging environment..."
        # Add your deployment commands here
        # Example: kubectl apply, docker-compose up, etc.

  # Deploy to production
  deploy-production:
    needs: [build-and-push]
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    environment: production

    steps:
    - name: Check deployment secrets
      run: |
        if [ -z "$SERVER_HOST" ]; then echo "SERVER_HOST is not set"; exit 1; fi
        if [ -z "$SERVER_USER" ]; then echo "SERVER_USER is not set"; exit 1; fi
        if [ -z "$SSH_PRIVATE_KEY" ]; then echo "SSH_PRIVATE_KEY is not set"; exit 1; fi
        echo "All deployment secrets are configured"
      env:
        SERVER_HOST: ${{ secrets.SERVER_HOST }}
        SERVER_USER: ${{ secrets.SERVER_USER }}
        SSH_PRIVATE_KEY: ${{ secrets.SSH_PRIVATE_KEY }}

    - name: Check server connectivity
      run: |
        echo "üîç Checking server connectivity..."
        echo "Server IP: ${{ secrets.SERVER_HOST }}"

        # Test basic connectivity
        ping -c 3 ${{ secrets.SERVER_HOST }} || echo "‚ùå Ping failed (may be blocked by firewall)"

        # Test SSH port
        timeout 10 nc -zv ${{ secrets.SERVER_HOST }} 22 || echo "‚ùå Cannot reach SSH port 22"

        # Test HTTP port (if available)
        timeout 5 nc -zv ${{ secrets.SERVER_HOST }} 80 || echo "‚ùå Cannot reach HTTP port 80"

        echo "‚úÖ Connectivity check completed"

        # If SSH fails, provide troubleshooting info
        if ! timeout 5 nc -zv ${{ secrets.SERVER_HOST }} 22 2>/dev/null; then
          echo "üîß TROUBLESHOOTING:"
          echo "1. Check if instance has Public IP"
          echo "2. Verify Security Lists allow port 22"
          echo "3. Check Network Security Groups (NSG)"
          echo "4. Ensure instance is in Public Subnet"
          echo "5. Check if firewall on instance blocks SSH"
        fi

    - name: Debug SSH
      run: |
        echo "üîß Testing SSH manually..."
        
        # Create .ssh directory and known_hosts if not exists
        mkdir -p ~/.ssh
        chmod 700 ~/.ssh
        touch ~/.ssh/known_hosts
        chmod 644 ~/.ssh/known_hosts
        
        # Add server to known_hosts
        ssh-keyscan -H ${{ secrets.SERVER_HOST }} >> ~/.ssh/known_hosts 2>/dev/null || echo "keyscan failed"
        
        # Create temporary key file
        echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/temp_key
        chmod 600 ~/.ssh/temp_key
        
        # Test SSH connection
        echo "üîë Testing SSH connection..."
        ssh -o ConnectTimeout=10 -o StrictHostKeyChecking=no -i ~/.ssh/temp_key ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} "echo 'SSH connection successful!'; whoami; pwd" || echo "‚ùå SSH failed"
        
        # Cleanup
        rm -f ~/.ssh/temp_key    

    - name: Deploy to Oracle Cloud
      uses: appleboy/ssh-action@v1.0.3
      with:
        host: ${{ secrets.SERVER_HOST }}
        username: ${{ secrets.SERVER_USER }}
        key: ${{ secrets.SSH_PRIVATE_KEY }}
        port: 22
        timeout: 60s
        debug: true
        script_stop: true
        script: |
          # Debug: Show current user and directory
          echo "üîç Current user: $(whoami)"
          echo "üîç Current directory: $(pwd)"
          echo "üîç Home directory: $HOME"
          
          # Show disk space and permissions
          echo "üîç Disk space:"
          df -h $HOME
          echo "üîç Home directory permissions:"
          ls -la $HOME
          
          # Check if project directory exists
          PROJECT_DIR="$HOME/todo-app"
          if [ ! -d "$PROJECT_DIR" ]; then
            echo "üìÅ Project directory not found, cloning repository..."
            cd $HOME
            git clone https://github.com/${{ github.repository }}.git todo-app || {
              echo "‚ùå Git clone failed"
              exit 1
            }
            cd todo-app
          else
            echo "üìÅ Project directory found, updating..."
            cd "$PROJECT_DIR" || {
              echo "‚ùå Cannot access project directory"
              exit 1
            }
            
            # Pull latest changes
            git pull origin main || echo "‚ö†Ô∏è Git pull failed, continuing..."
          fi

          # Check if docker directory exists
          if [ ! -d "docker" ]; then
            echo "‚ùå Docker directory not found!"
            ls -la
            exit 1
          fi

          # Navigate to docker directory
          cd docker
          echo "üìÇ In docker directory: $(pwd)"
          ls -la

          # Check if user can run docker
          echo "üê≥ Checking Docker access..."
          docker ps || {
            echo "‚ùå Docker access failed, trying with sudo..."
            sudo docker ps || {
              echo "‚ùå Docker not accessible even with sudo"
              exit 1
            }
            # Use sudo for docker commands
            sudo docker-compose down || echo "‚ö†Ô∏è Docker compose down failed"
            sudo docker-compose up -d --build || {
              echo "‚ùå Docker compose up failed"
              exit 1
            }
            sudo docker image prune -f || echo "‚ö†Ô∏è Image prune failed"
            sudo docker-compose ps
            exit 0
          }

          # Regular docker commands (without sudo)
          echo "üîΩ Stopping existing containers..."
          docker-compose down || echo "‚ö†Ô∏è Docker compose down failed"

          echo "üöÄ Starting containers..."
          docker-compose up -d --build || {
            echo "‚ùå Docker compose up failed"
            exit 1
          }

          echo "üßπ Cleaning up old images..."
          docker image prune -f || echo "‚ö†Ô∏è Image prune failed"

          echo "üìä Container status:"
          docker-compose ps
